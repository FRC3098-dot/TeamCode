// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.util.Constants;
//import frc.robot.util.Constants.FuelConstants;
import frc.robot.util.Constants.ClimberConstants;

import com.revrobotics.RelativeEncoder;
import com.revrobotics.spark.FeedbackSensor;
import com.revrobotics.spark.SparkBase.ControlType;
import com.revrobotics.spark.SparkBase.PersistMode;
import com.revrobotics.spark.SparkBase.ResetMode;
import com.revrobotics.spark.SparkClosedLoopController;
import com.revrobotics.spark.config.SparkBaseConfig;
import com.revrobotics.spark.config.SparkBaseConfig.IdleMode;
import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.config.SparkMaxConfig;
import com.revrobotics.spark.SparkLowLevel.MotorType;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.controller.ElevatorFeedforward;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.math.trajectory.TrapezoidProfile.Constraints;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

// Ignore unused variable warnings
@SuppressWarnings("unused") 

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class ClimberSubsystem extends SubsystemBase {
   
    private SparkMax climberMotor = new SparkMax(ClimberConstants.kElevatorMotor, MotorType.kBrushless);
    private SparkBaseConfig climberMotorConfig = new SparkMaxConfig();
    private RelativeEncoder m_climberEncoder;
    private final SparkClosedLoopController climbPosPID;
    private final ProfiledPIDController m_ClimbPID  = new ProfiledPIDController(ClimberConstants.kElevatorkP,
                                                                        ClimberConstants.kElevatorkI,
                                                                        ClimberConstants.kElevatorkD, 
                                                                        ClimberConstants.TrapezoidProfileConstants.kElevatorCONSTRAINTS);
    private DigitalInput MinHeightLimit = new DigitalInput(ClimberConstants.kMinHeightLimit);
    private final ElevatorFeedforward m_climberFeedForward = new ElevatorFeedforward(ClimberConstants.kElevatorkS,
                                        ClimberConstants.kElevatorkG,
                                        ClimberConstants.kElevatorkV,
                                        ClimberConstants.kElevatorkA);
   
   
        @SuppressWarnings("removal")
        public ClimberSubsystem() {
     //Configure SparkMax Controller
        climberMotorConfig.idleMode(IdleMode.kBrake);
        climberMotorConfig.inverted(false);
        climberMotorConfig.smartCurrentLimit(40);
        climberMotorConfig.closedLoopRampRate(ClimberConstants.kElevatorRampRate);
        climberMotorConfig.encoder
                .positionConversionFactor(ClimberConstants.kElevRot2Meters)
                .velocityConversionFactor(ClimberConstants.kElevatorRotRPMRadsperSecond);
        
        climberMotorConfig.closedLoop
                .feedbackSensor(FeedbackSensor.kPrimaryEncoder)
                .pidf(
                    ClimberConstants.kElevatorkP,
                    ClimberConstants.kElevatorkI,
                    ClimberConstants.kElevatorkD,
                    ClimberConstants.kElevatorkFF 
                );
    // .velocityFF(ClimberConstants.kVelocityFF)
        // .outputRange(-1.0, 1.0);
      //  .outputRange(-0.8, 0.8);

        climberMotor.configure(climberMotorConfig, com.revrobotics.ResetMode.kResetSafeParameters, com.revrobotics.PersistMode.kPersistParameters);
   
    //Define PID Controllers
    climbPosPID = climberMotor.getClosedLoopController();

    //Define Climber Encoder
    m_climberEncoder = climberMotor.getEncoder();
       
     //Zero encoder
    setClimberEncoderZero();
      
}

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        updateSmartDashboardClimb();
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }
  
    public void setClimberPoseManual(double spd) {
        if(!MinHeightLimit.get() && spd>0){
            climberMotor.set(spd);
            }
        else if ((MinHeightLimit.get() )){
            climberMotor.set(spd);
            }
        else{
             stopClimber();}
        
        /*if (MaxHeightLimit.get() && MinHeightLimit.get()){
            climberMotor.set(spd);
            }
        else if (MaxHeightLimit.get() && !MinHeightLimit.get() && spd>0){
          climberMotor.set(spd);
            }
        else if ((!MaxHeightLimit.get() && MinHeightLimit.get() && spd<0)){
            climberMotor.set(spd);
            }
           else{
             stopClimber();
            }*/
            
    } 
    
    /*public void setElevatorPoseCmd(double height) {
        ElevposPID.setReference(height,ControlType.kPosition);
      }   */

    public void setClimberPose(double height) { 
        climbPosPID.setSetpoint(height,ControlType.kPosition);
        SmartDashboard.putNumber("Climber Height Command",height);
    }
    public void setClimberEncoderZero(){
        m_climberEncoder.setPosition(0);
    }
    public boolean isAtTarget(double height) {
        return Math.abs(getClimberPosition() - height) < 0.01; // Tolerance
        }
    public double getClimberPosition() {
        return m_climberEncoder.getPosition();
    }
    public void setClimberPoseZero (){
        climbPosPID.setSetpoint(0.0, 
        ControlType.kPosition);
    }
    public void stopClimber(){
        climberMotor.set(0);
    }
    public void updateSmartDashboardClimb(){
    SmartDashboard.putNumber("Climber Position Meters", m_climberEncoder.getPosition());
    SmartDashboard.putNumber("Climber Position inches", m_climberEncoder.getPosition() * 39.3701);
    SmartDashboard.putBoolean("Climber Min Limit:", MinHeightLimit.get());
    }
}